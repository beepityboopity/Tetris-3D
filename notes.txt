RS24Iv81
4Tv89JefF6e3Mc5v
7kNTM60V2?






















TODO
----

different colored blocks - Done
multiple camera views - Done
randomized new block type - Done
add new block types - Done
adjust block positions for better rotation - Done
start/pause buttons - Done
score - Done
adjust keybinds - Done
music
anti aliasing - Done
make the code pretty





Q+E rotate camera
W+A+S+D move piece
J+K+L rotate piece
R pause game














PROCESS ------------------------------------------------------------------------

Initialization:
- set active piece to branch
  (set active piece position)
- fill cube array with placeholder cubes
- add temporary blocks to test collision
[call order array] <-- unnecessary?
- shader and texture setup (no change needed yet)
- initialize shader variables

While:

- camera input
- piece movement (inactive for testing)
- piece rotation (build in progress)
- piece gravity (inactive for testing)
- set camera position
- draw playing field
- draw active piece
- draw present pieces in cube array
- event polling

Terminate:

- delete buffers
- end program

FUNCTIONS ------------------------------------------------------------------------

camInput: (while loop)

adjusts global camera variables based on key input
rotation = I, K, J, L
zoom = Q, E
sets variable limits

moveActive: (while loop)

moves active piece within certain limits
movement keys: W, S, A, D
TEMP: press M for newPieceSpawn
call collisionTest, add to temp

rotateActive: (while loop)

gravity: (while loop)

collisionTest: (moveActive)

newPieceSpawn: (temp moveActive, gravity)

completionCheck: (newPieceSpawn, self)










**************************************************************
OLD NOTES
**************************************************************

8 piece tetrominos
pieces = 0.1 size of playing field
tetrominos spawn 1.5 away from center
pieces are stored as vec3 positions +- 0.05

randomly select direction
spawn cube 1.5 away in that direction
every second cube moves 0.1 in the opposite direction
cube stops when it is 2.0 away from original position

active piece:
8 cube positions, 1 color ID
when movement: all position at index +- movement

move collision:
for all piece cubes, if new position in cube array, dont

falling: 
for all piece cubes, if new position in cube array, stop, 
add all cube and color ID to cube array, create new active piece

creating new piece:
randomly select piece type, place at top, make it active

shapes:
cube:

(0.0, 0.0, 0.0)
(0.0, 0.0, 0.05)
(0.0, 0.05, 0.0)
(0.0, 0.05, 0.05)
(0.05, 0.0, 0.0)
(0.05, 0.0, 0.05)
(0.05, 0.05, 0.0)
(0.05, 0.05, 0.05)

I:

(0.0, 0.0, 0.0)
(0.05, 0.0, 0.0)
(0.1, 0.0, 0.0)
(0.05, 0.05, 0.0)
(0.05, 0.1, 0.0)
(0.0, 0.15, 0.0)
(0.05, 0.15, 0.0)
(0.1, 0.15, 0.0)

Long:

(0.0, 0.0, 0.0)
(0.0, 0.05, 0.0)
(0.0, 0.1, 0.0)
(0.0, 0.15, 0.0)
(0.0, 0.2, 0.0)
(0.0, 0.25, 0.0)
(0.0, 0.3, 0.0)
(0.0, 0.35, 0.0)








completion check
----------------

[...cube to check completion on...]

checking line at y,z <- list of axis to check
collect all cube with matching y,z
if 10: completed

assume completed
assume -y gravity

find and collect all cube in >y,z
apply gravity to found cubes

for all found cube, check completion

------------------------------------

if gravity axis not in checked line plane axis, no need to apply gravity

axis to check per cube: x,y - y,z - x,z

--------
ROTATION
--------





